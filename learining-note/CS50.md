## CS50

### learning record

[CS50](https://cs50.harvard.edu/ai/2024/)

1. Week 0 Search 8:00 2024-8-16 0:25
2. Week 0 Search 25:06 2024-8-16 17:27
3. Week 0 Search 1:32:40 2024-8-19 16:55
4. Week 0 Search 1:47:20 2024-8-20 23:23
5. Week 0 Search project:degree 2024-8-29 0:58

### note

#### key word

1. **transition model**

2. **state space**

3. **goal test**

4. **path cost**

5. **solution**

6. **optimal solution**

7. **node** : a data structure that keeps a track of 

   * a state

   + a parent(a node that generated this node)

   + an action(action applied to parent node to get this node)

   + a path cost (from initial node to this node)

8. **Approach**:

   * Start with a **frontier** (the set of nodes that are discovered but not yet explored)that contains the initial state
   * Repeat:
     * If the frontier is empty,return no solution
     * Remove a node from the frontier
     * If the removed note contain the goal state,return the solution
     * Expand node:add  **resulting nodes**(nodes that are generated by the removed note through some actions) to the frontier

   * But there is a new problem:**looping problem**

     ![1723800007520](C:\Users\1310134454\AppData\Roaming\Typora\typora-user-images\1723800007520.png)

9. **Revived Approach**

   - Start with a **frontier** (<u>the set of nodes that are discovered but not yet explored</u>)that contains the initial state.
   - Start with an empty explored set.
   - Repeat:
     - If the frontier is empty,return no solution
     - Remove a node from the frontier
     - If the removed note contain the goal state,return the solution
     - Expand node:add  **resulting nodes**(<u>nodes that are generated by the removed note through some actions</u>) to the frontier if they aren't in the frontier or the explored set.


#### Search Algorithms

##### Depth-first search

##### Breadth-first search

##### Greedy best-first search

Expands the note that is the closest to the goal,as estimated by a heuristic function **h(n)**

##### A* search

 lowest value of **g(n) + h(n)**<u>(**g(n)**is the cost to reach the current node)</u>

##### Adversarial search

**Key word**

* S<sub>0</sub>: initial state
* Player(s): returns which state to move in state s
* Actions(s): returns legal moves in state s
* Result(s,a): returns state after action a taken in state s
* Terminal(s): checks if state s is a terminal state
* Utility(s): final numerical value for state s 

1. Minimax: 
   * Max(X) aims to maximize the score
   * Min(O)  aims to minimize the score

**Minimax**

* Given a state s:
  * Max picks a in Actions(s) that produces the highest value of Min-Value(Result(s,a))<u>(Since the opponent aims to minimize the value, Max needs to think what Min may do?)</u>
  * Min picks a in Actions(s) that produces the smallest value of Max-Value(Result(s,a))

* function Max-Value(state):

  ​	//The function aims to return the max value that may be produced from the state.

  ​	if (Terminal(state)):

  ​		return Utility(state)

  ​	v = &minus;&infin;

  ​	for action in Actions(state):

  ​		v = Max(v,Min-Value(Result(state,action)))//Because the next move is your opponent‘s turn, you need to think about what he will do to minimize the value.

  ​	return v

* function Min-Value(state): similar to the Max-Value.	

**optimization: Alpha-Beta Pruning**

Actually,there're a lot of nodes whose values we don't need to calculate,such as:

**before optimization:**

![1724146136876](C:\Users\1310134454\AppData\Roaming\Typora\typora-user-images\1724146136876.png)

**after optimization:**

![1724146158650](C:\Users\1310134454\AppData\Roaming\Typora\typora-user-images\1724146158650.png)

##### Depth-Limited Minimax

**key word**

* evaluation function:function that estimates the expected utility of the game from a given state

For example, if 1 represents A winning, -1 represents B winning, and 0 represents a tie, then 0.8 would indicate that A has a good chance of winning.